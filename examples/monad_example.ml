
open Ocat

(* Other examples are all about demystifying monads. Here, we are going to add
   some more magic to the mix!
*)
module Magic_example = struct

  (* The [Magic] module encapsulates magic tricks that depend on a magic word.
     In muggle society, this is known as the [Reader] monad. *)
  module Magic = struct
    type 'a t = Conjure of (word -> 'a)
    and word =
      | Presto
      | Abracadabra

    (* This convenience function makes a Conjuration appear from nowhere. *)
    let conjure f = Conjure f

    (* A spell is woven by saying the magic word. *)
    let say inc = function Conjure f -> f inc

    (* Below is the profane boilerplate we need to write to get a free [Monad] module *)

    let return a = Conjure (fun _ -> a)

    let bind g = function Conjure f ->
      Conjure (fun i -> f i |> g |> function Conjure h -> h i)
  end

  include Magic
  include Monad (Magic)

  let etymology = conjure @@ function
    | Presto -> "italian"
    | Abracadabra -> "(maybe) aramaic"

  let describe n =
    conjure @@ function
    | Presto -> Fmt.pr "%d flowers appear when using 'Presto'" n
    | Abracadabra -> Fmt.pr "%d rabbits appear when using 'Abracadabra'" n

  let magic_show word =
    (* We start with some string - nothing up my sleeves! *)
    return "3"
    (* Sometimes we just need some profane functions. *)
    >|=  int_of_string
    (* The [describe] function wants to know the magic word. *)
    >>= describe
    (* Now let's scrutinize the magic word. *)
    >>= (fun _ -> etymology)
    (* Note how the printing logic is entirely orthogonal to magic. *)
    >|= (fun origin -> Fmt.pr ", which is %s.\n" origin)
    (* Finally, we start the show by saying the magic word. *)
    |> say word

  let _ =
    Fmt.pr "Magic monadic reader:\n";
    magic_show Presto;
    magic_show Abracadabra
end

module Who_needs_do_notation = struct
  open Ocat_modules.Option

  let _ = Fmt.pr "Monadic vCard generated by cool notation:\n"

  let print_opt = function
    | Some (n, (d, e), p, w) -> Fmt.pr "%s (%d%s in %s) - %s\n" n d e p w
    | None -> Fmt.pr "<unknown>\n"

  (* Let's define some monadic facts about the Buddha. *)
  let name = Some "Siddhartha Gautama"
  let date_of_birth = Some (563, "BC")
  let place_of_birth = Some "Lumbini"
  let wikipedia_article = Some "https://en.wikipedia.org/wiki/Gautama_Buddha"

  (* And now for the fun part: unpack the values in a sequence of [bind]s. *)
  let _ =
    let maybe =
      name >>= fun n ->
      place_of_birth >>= fun p ->
      date_of_birth >>= fun (d, e) ->
      wikipedia_article >|= fun w -> (* Note that the last operation is map, not bind. *)
      (n, d, e, p, w)
    in maybe |> foreach @@ function
    | (n, d, e, p, w) -> Fmt.pr "%s (%d%s in %s) - %s\n" n d e p w

  (* Someone else we might be interested in. *)
  let name = Some "John le Fucker"
  let date_of_birth = None
  let place_of_birth = None
  let wikipedia_article = Some "https://en.wikipedia.org/wiki/John_le_Fucker"

  (* Nothing will be printed because the circumstances of Mr le Fucker's birth
     are not well documented. *)
  let _ =
    let maybe =
      name >>= fun n ->
      place_of_birth >>= fun p ->
      date_of_birth >>= fun (d, e) ->
      wikipedia_article >|= fun w ->
      (n, d, e, p, w)
    in maybe |> foreach @@ function
    | (n, d, e, p, w) -> Fmt.pr "%s (%d%s in %s) - %s\n" n d e p w

end
